--
-- PostgreSQL database dump
--

-- Dumped from database version 14.3
-- Dumped by pg_dump version 14.3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: Abouts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."Abouts" (
    "AboutID" integer NOT NULL,
    "AboutDetails1" text NOT NULL,
    "AboutDetails2" text NOT NULL,
    "AboutImage1" text NOT NULL,
    "AboutImage2" text NOT NULL,
    "AboutMapLocation" text NOT NULL,
    "AboutStatus" boolean NOT NULL
);


ALTER TABLE public."Abouts" OWNER TO postgres;

--
-- Name: Abouts_AboutID_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."Abouts" ALTER COLUMN "AboutID" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Abouts_AboutID_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: Blogs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."Blogs" (
    "BlogID" integer NOT NULL,
    "BlogTitle" text NOT NULL,
    "BlogContent" text NOT NULL,
    "BlogThumbnailImage" text NOT NULL,
    "Image" text NOT NULL,
    "BlogCreateDate" timestamp with time zone NOT NULL,
    "BlogStatus" boolean NOT NULL,
    "CategoryID" integer DEFAULT 0 NOT NULL,
    "WriterID" integer DEFAULT 0 NOT NULL
);


ALTER TABLE public."Blogs" OWNER TO postgres;

--
-- Name: Blogs_BlogID_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."Blogs" ALTER COLUMN "BlogID" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Blogs_BlogID_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: Categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."Categories" (
    "CategoryID" integer NOT NULL,
    "CategoryName" text NOT NULL,
    "CategoryDescription" text NOT NULL,
    "CategoryStatus" boolean NOT NULL
);


ALTER TABLE public."Categories" OWNER TO postgres;

--
-- Name: Categories_CategoryID_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."Categories" ALTER COLUMN "CategoryID" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Categories_CategoryID_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: Comments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."Comments" (
    "CommentID" integer NOT NULL,
    "CommentUsername" text NOT NULL,
    "CommentTitle" text NOT NULL,
    "CommentContent" text NOT NULL,
    "CommentDate" timestamp with time zone NOT NULL,
    "CommentStatus" boolean NOT NULL,
    "BlogID" integer DEFAULT 0 NOT NULL
);


ALTER TABLE public."Comments" OWNER TO postgres;

--
-- Name: Comments_CommentID_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."Comments" ALTER COLUMN "CommentID" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Comments_CommentID_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: Contacts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."Contacts" (
    "ContactID" integer NOT NULL,
    "ContactUsername" text NOT NULL,
    "CantactMail" text NOT NULL,
    "ContactSubject" text NOT NULL,
    "ContactMessage" text NOT NULL,
    "ContactDate" timestamp with time zone NOT NULL,
    "ContactStatus" boolean NOT NULL
);


ALTER TABLE public."Contacts" OWNER TO postgres;

--
-- Name: Contacts_ContactID_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."Contacts" ALTER COLUMN "ContactID" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Contacts_ContactID_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: Writers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."Writers" (
    "WriterID" integer NOT NULL,
    "WriterName" text NOT NULL,
    "WriterAbaout" text NOT NULL,
    "WriterImage" text NOT NULL,
    "WriterMail" text NOT NULL,
    "WriterPassword" text NOT NULL,
    "WriterStatus" boolean NOT NULL
);


ALTER TABLE public."Writers" OWNER TO postgres;

--
-- Name: Writers_WriterID_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."Writers" ALTER COLUMN "WriterID" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public."Writers_WriterID_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: __EFMigrationsHistory; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."__EFMigrationsHistory" (
    "MigrationId" character varying(150) NOT NULL,
    "ProductVersion" character varying(32) NOT NULL
);


ALTER TABLE public."__EFMigrationsHistory" OWNER TO postgres;

--
-- Data for Name: Abouts; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Abouts" ("AboutID", "AboutDetails1", "AboutDetails2", "AboutImage1", "AboutImage2", "AboutMapLocation", "AboutStatus") FROM stdin;
\.


--
-- Data for Name: Blogs; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Blogs" ("BlogID", "BlogTitle", "BlogContent", "BlogThumbnailImage", "Image", "BlogCreateDate", "BlogStatus", "CategoryID", "WriterID") FROM stdin;
1	C# ile Asenkron Metotlar	Bu bölümde, yazdığımız Windows programının cevap verebilirliğini artıran bir yöntem göreceğiz. Bu yöntemde işlemci bir çevre bileşenine bir emir verir, ancak bu emrin yerine getirilmesini beklemez, kendi işine devam eder. Çevre birimi ilgili işi tamamladığında bir interrupt ile bunu işlemciye bildirir. Fark ettiğiniz üzere burada tek thread çalışmaktadır. Aslında asenkron programlama ile yaptığımız şeyi birden fazla thread açarak da yapabiliriz. Ancak asenkron programlama yöntemi bütün işi tek bir thread ile hallettiği için birden fazla thread kullanma yaklaşımına göre daha verimlidir.\n\nBir Windows form uygulaması programın kesildiği yerde donar. Buradaki kesilmekten kastımız işlemcinin bir metottaki bir satırda bir süre takılıp kalması, ilerlememesidir. Bu takılmaların çoğunda işlemci başka bir çevre biriminin iş yapmasını bekler, ancak bazen de yoğun işlemci gücü gerektiren işlemler yapılabilir. Asenkron programlama yaklaşımı birinci durumda kullanılabilir. İkinci durumda programın cevap verebilirliğini sağlamak için yeni thread açılması kaçınılmazdır.\n\nBir Windows form uygulamasının donması kullanıcı deneyimi açısından çok kötü bir şeydir. Formun üzerindeki kontroller tepki vermez hale gelir, hatta program penceresinin sağ üst kısmındaki kapatma, simge durumuna küçültme ve ekranı kaplama düğmeleri de çalışmaz hale gelir. Böyle bir durumda çoğu kullanıcı programın kilitlendiğini sanarak CTRL+ALT+DEL kısayolunu kullanarak programı kapatır.\n\nForm tabanlı uygulamalarda program akışının kesilmesi formun donmasına neden olur. Çünkü formlar mesaj döngüsü mantığında çalışır. Bir formda sürekli sonsuz bir while döngüsünde dönülür. Bu while döngüsünün içinde formun kullanıcı eylemlerine tepki vermesini sağlayan kodlar bulunur, örneğin fare işaretçisinin bir butonun üzerine getirildiğinde butonun renk değiştirmesi gibi. Ayrıca form formun üzerindeki kontrollerin özelliklerine göre sürekli güncellenir. Örneğin formun üzerindeki bir butonun üzerinde bir metni değiştirmişsek bu değişiklik while döngüsünün sıradaki ilk iterasyonunda görüntüye yansıtılır. Son olarak bir metot çağrısı yaptığımızda da bu döngü yarıda kalır, metodun işlemleri yapılır, sonra kalınan yerden döngüye geri dönülür. İşte işlemi uzun süren bir metot çağrısı yaptığımızda formun donmasının sebebi budur. Ayrıca işletim sistemi belirli aralıklarla forma formun hayatta olup olmadığını öğrenmek için mesaj gönderir. Form da hayatta olduğuna ilişkin mesajı göndererek cevap verir. Bu işlem de mesaj döngüsünün içinde yapılır. Programımız bir metot içinde uzun süre kalırsa işletim sistemi bu mesajlara cevap alamaz ve programı "cevap vermiyor" (not responding) olarak işaretler. Windows, cevap vermeyen uygulamaların pencerelerini ilgili pencereyle aynı boyutlarda bir hayalet pencereyle değiştirir.	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/6.jpg	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/6.jpg	2022-05-25 00:00:00+03	t	1	1
2	SQL CRUD işlemleri	Bu bölümde, yazdığımız Windows programının cevap verebilirliğini artıran bir yöntem göreceğiz. Bu yöntemde işlemci bir çevre bileşenine bir emir verir, ancak bu emrin yerine getirilmesini beklemez, kendi işine devam eder. Çevre birimi ilgili işi tamamladığında bir interrupt ile bunu işlemciye bildirir. Fark ettiğiniz üzere burada tek thread çalışmaktadır. Aslında asenkron programlama ile yaptığımız şeyi birden fazla thread açarak da yapabiliriz. Ancak asenkron programlama yöntemi bütün işi tek bir thread ile hallettiği için birden fazla thread kullanma yaklaşımına göre daha verimlidir.\n\nBir Windows form uygulaması programın kesildiği yerde donar. Buradaki kesilmekten kastımız işlemcinin bir metottaki bir satırda bir süre takılıp kalması, ilerlememesidir. Bu takılmaların çoğunda işlemci başka bir çevre biriminin iş yapmasını bekler, ancak bazen de yoğun işlemci gücü gerektiren işlemler yapılabilir. Asenkron programlama yaklaşımı birinci durumda kullanılabilir. İkinci durumda programın cevap verebilirliğini sağlamak için yeni thread açılması kaçınılmazdır.\n\nBir Windows form uygulamasının donması kullanıcı deneyimi açısından çok kötü bir şeydir. Formun üzerindeki kontroller tepki vermez hale gelir, hatta program penceresinin sağ üst kısmındaki kapatma, simge durumuna küçültme ve ekranı kaplama düğmeleri de çalışmaz hale gelir. Böyle bir durumda çoğu kullanıcı programın kilitlendiğini sanarak CTRL+ALT+DEL kısayolunu kullanarak programı kapatır.\n\nForm tabanlı uygulamalarda program akışının kesilmesi formun donmasına neden olur. Çünkü formlar mesaj döngüsü mantığında çalışır. Bir formda sürekli sonsuz bir while döngüsünde dönülür. Bu while döngüsünün içinde formun kullanıcı eylemlerine tepki vermesini sağlayan kodlar bulunur, örneğin fare işaretçisinin bir butonun üzerine getirildiğinde butonun renk değiştirmesi gibi. Ayrıca form formun üzerindeki kontrollerin özelliklerine göre sürekli güncellenir. Örneğin formun üzerindeki bir butonun üzerinde bir metni değiştirmişsek bu değişiklik while döngüsünün sıradaki ilk iterasyonunda görüntüye yansıtılır. Son olarak bir metot çağrısı yaptığımızda da bu döngü yarıda kalır, metodun işlemleri yapılır, sonra kalınan yerden döngüye geri dönülür. İşte işlemi uzun süren bir metot çağrısı yaptığımızda formun donmasının sebebi budur. Ayrıca işletim sistemi belirli aralıklarla forma formun hayatta olup olmadığını öğrenmek için mesaj gönderir. Form da hayatta olduğuna ilişkin mesajı göndererek cevap verir. Bu işlem de mesaj döngüsünün içinde yapılır. Programımız bir metot içinde uzun süre kalırsa işletim sistemi bu mesajlara cevap alamaz ve programı "cevap vermiyor" (not responding) olarak işaretler. Windows, cevap vermeyen uygulamaların pencerelerini ilgili pencereyle aynı boyutlarda bir hayalet pencereyle değiştirir.	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/7.jpg	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/7.jpg	2022-05-26 00:00:00+03	t	1	2
3	Javascript Taş-Kağıt-Makas Oyunu	Bu bölümde, yazdığımız Windows programının cevap verebilirliğini artıran bir yöntem göreceğiz. Bu yöntemde işlemci bir çevre bileşenine bir emir verir, ancak bu emrin yerine getirilmesini beklemez, kendi işine devam eder. Çevre birimi ilgili işi tamamladığında bir interrupt ile bunu işlemciye bildirir. Fark ettiğiniz üzere burada tek thread çalışmaktadır. Aslında asenkron programlama ile yaptığımız şeyi birden fazla thread açarak da yapabiliriz. Ancak asenkron programlama yöntemi bütün işi tek bir thread ile hallettiği için birden fazla thread kullanma yaklaşımına göre daha verimlidir.\n\nBir Windows form uygulaması programın kesildiği yerde donar. Buradaki kesilmekten kastımız işlemcinin bir metottaki bir satırda bir süre takılıp kalması, ilerlememesidir. Bu takılmaların çoğunda işlemci başka bir çevre biriminin iş yapmasını bekler, ancak bazen de yoğun işlemci gücü gerektiren işlemler yapılabilir. Asenkron programlama yaklaşımı birinci durumda kullanılabilir. İkinci durumda programın cevap verebilirliğini sağlamak için yeni thread açılması kaçınılmazdır.\n\nBir Windows form uygulamasının donması kullanıcı deneyimi açısından çok kötü bir şeydir. Formun üzerindeki kontroller tepki vermez hale gelir, hatta program penceresinin sağ üst kısmındaki kapatma, simge durumuna küçültme ve ekranı kaplama düğmeleri de çalışmaz hale gelir. Böyle bir durumda çoğu kullanıcı programın kilitlendiğini sanarak CTRL+ALT+DEL kısayolunu kullanarak programı kapatır.\n\nForm tabanlı uygulamalarda program akışının kesilmesi formun donmasına neden olur. Çünkü formlar mesaj döngüsü mantığında çalışır. Bir formda sürekli sonsuz bir while döngüsünde dönülür. Bu while döngüsünün içinde formun kullanıcı eylemlerine tepki vermesini sağlayan kodlar bulunur, örneğin fare işaretçisinin bir butonun üzerine getirildiğinde butonun renk değiştirmesi gibi. Ayrıca form formun üzerindeki kontrollerin özelliklerine göre sürekli güncellenir. Örneğin formun üzerindeki bir butonun üzerinde bir metni değiştirmişsek bu değişiklik while döngüsünün sıradaki ilk iterasyonunda görüntüye yansıtılır. Son olarak bir metot çağrısı yaptığımızda da bu döngü yarıda kalır, metodun işlemleri yapılır, sonra kalınan yerden döngüye geri dönülür. İşte işlemi uzun süren bir metot çağrısı yaptığımızda formun donmasının sebebi budur. Ayrıca işletim sistemi belirli aralıklarla forma formun hayatta olup olmadığını öğrenmek için mesaj gönderir. Form da hayatta olduğuna ilişkin mesajı göndererek cevap verir. Bu işlem de mesaj döngüsünün içinde yapılır. Programımız bir metot içinde uzun süre kalırsa işletim sistemi bu mesajlara cevap alamaz ve programı "cevap vermiyor" (not responding) olarak işaretler. Windows, cevap vermeyen uygulamaların pencerelerini ilgili pencereyle aynı boyutlarda bir hayalet pencereyle değiştirir.	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/8.jpg	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/8.jpg	2022-07-20 00:00:00+03	t	1	1
16	Furkanın Çözümü	adasdasda Bu bölümde, yazdığımız Windows programının cevap verebilirliğini artıran bir yöntem göreceğiz. Bu yöntemde işlemci bir çevre bileşenine bir emir verir, ancak bu emrin yerine getirilmesini beklemez, kendi işine devam eder. Çevre birimi ilgili işi tamamladığında bir interrupt ile bunu işlemciye bildirir. Fark ettiğiniz üzere burada tek thread çalışmaktadır. Aslında asenkron programlama ile yaptığımız şeyi birden fazla thread açarak da yapabiliriz. Ancak asenkron programlama yöntemi bütün işi tek bir thread ile hallettiği için birden fazla thread kullanma yaklaşımına göre daha verimlidir.\n\nBir Windows form uygulaması programın kesildiği yerde donar. Buradaki kesilmekten kastımız işlemcinin bir metottaki bir satırda bir süre takılıp kalması, ilerlememesidir. Bu takılmaların çoğunda işlemci başka bir çevre biriminin iş yapmasını bekler, ancak bazen de yoğun işlemci gücü gerektiren işlemler yapılabilir. Asenkron programlama yaklaşımı birinci durumda kullanılabilir. İkinci durumda programın cevap verebilirliğini sağlamak için yeni thread açılması kaçınılmazdır.\n\nBir Windows form uygulamasının donması kullanıcı deneyimi açısından çok kötü bir şeydir. Formun üzerindeki kontroller tepki vermez hale gelir, hatta program penceresinin sağ üst kısmındaki kapatma, simge durumuna küçültme ve ekranı kaplama düğmeleri de çalışmaz hale gelir. Böyle bir durumda çoğu kullanıcı programın kilitlendiğini sanarak CTRL+ALT+DEL kısayolunu kullanarak programı kapatır.\n\nForm tabanlı uygulamalarda program akışının kesilmesi formun donmasına neden olur. Çünkü formlar mesaj döngüsü mantığında çalışır. Bir formda sürekli sonsuz bir while döngüsünde dönülür. Bu while döngüsünün içinde formun kullanıcı eylemlerine tepki vermesini sağlayan kodlar bulunur, örneğin fare işaretçisinin bir butonun üzerine getirildiğinde butonun renk değiştirmesi gibi. Ayrıca form formun üzerindeki kontrollerin özelliklerine göre sürekli güncellenir. Örneğin formun üzerindeki bir butonun üzerinde bir metni değiştirmişsek bu değişiklik while döngüsünün sıradaki ilk iterasyonunda görüntüye yansıtılır. Son olarak bir metot çağrısı yaptığımızda da bu döngü yarıda kalır, metodun işlemleri yapılır, sonra kalınan yerden döngüye geri dönülür. İşte işlemi uzun süren bir metot çağrısı yaptığımızda formun donmasının sebebi budur. Ayrıca işletim sistemi belirli aralıklarla forma formun hayatta olup olmadığını öğrenmek için mesaj gönderir. Form da hayatta olduğuna ilişkin mesajı göndererek cevap verir. Bu işlem de mesaj döngüsünün içinde yapılır. Programımız bir metot içinde uzun süre kalırsa işletim sistemi bu mesajlara cevap alamaz ve programı "cevap vermiyor" (not responding) olarak işaretler. Windows, cevap vermeyen uygulamaların pencerelerini ilgili pencereyle aynı boyutlarda bir hayalet pencereyle değiştirir.	testt	test	2022-06-21 00:00:00+03	t	4	2
17	Deneme Bloğu 2	Deneme deneme denemee Bu bölümde, yazdığımız Windows programının cevap verebilirliğini artıran bir yöntem göreceğiz. Bu yöntemde işlemci bir çevre bileşenine bir emir verir, ancak bu emrin yerine getirilmesini beklemez, kendi işine devam eder. Çevre birimi ilgili işi tamamladığında bir interrupt ile bunu işlemciye bildirir. Fark ettiğiniz üzere burada tek thread çalışmaktadır. Aslında asenkron programlama ile yaptığımız şeyi birden fazla thread açarak da yapabiliriz. Ancak asenkron programlama yöntemi bütün işi tek bir thread ile hallettiği için birden fazla thread kullanma yaklaşımına göre daha verimlidir.\n\nBir Windows form uygulaması programın kesildiği yerde donar. Buradaki kesilmekten kastımız işlemcinin bir metottaki bir satırda bir süre takılıp kalması, ilerlememesidir. Bu takılmaların çoğunda işlemci başka bir çevre biriminin iş yapmasını bekler, ancak bazen de yoğun işlemci gücü gerektiren işlemler yapılabilir. Asenkron programlama yaklaşımı birinci durumda kullanılabilir. İkinci durumda programın cevap verebilirliğini sağlamak için yeni thread açılması kaçınılmazdır.\n\nBir Windows form uygulamasının donması kullanıcı deneyimi açısından çok kötü bir şeydir. Formun üzerindeki kontroller tepki vermez hale gelir, hatta program penceresinin sağ üst kısmındaki kapatma, simge durumuna küçültme ve ekranı kaplama düğmeleri de çalışmaz hale gelir. Böyle bir durumda çoğu kullanıcı programın kilitlendiğini sanarak CTRL+ALT+DEL kısayolunu kullanarak programı kapatır.\n\nForm tabanlı uygulamalarda program akışının kesilmesi formun donmasına neden olur. Çünkü formlar mesaj döngüsü mantığında çalışır. Bir formda sürekli sonsuz bir while döngüsünde dönülür. Bu while döngüsünün içinde formun kullanıcı eylemlerine tepki vermesini sağlayan kodlar bulunur, örneğin fare işaretçisinin bir butonun üzerine getirildiğinde butonun renk değiştirmesi gibi. Ayrıca form formun üzerindeki kontrollerin özelliklerine göre sürekli güncellenir. Örneğin formun üzerindeki bir butonun üzerinde bir metni değiştirmişsek bu değişiklik while döngüsünün sıradaki ilk iterasyonunda görüntüye yansıtılır. Son olarak bir metot çağrısı yaptığımızda da bu döngü yarıda kalır, metodun işlemleri yapılır, sonra kalınan yerden döngüye geri dönülür. İşte işlemi uzun süren bir metot çağrısı yaptığımızda formun donmasının sebebi budur. Ayrıca işletim sistemi belirli aralıklarla forma formun hayatta olup olmadığını öğrenmek için mesaj gönderir. Form da hayatta olduğuna ilişkin mesajı göndererek cevap verir. Bu işlem de mesaj döngüsünün içinde yapılır. Programımız bir metot içinde uzun süre kalırsa işletim sistemi bu mesajlara cevap alamaz ve programı "cevap vermiyor" (not responding) olarak işaretler. Windows, cevap vermeyen uygulamaların pencerelerini ilgili pencereyle aynı boyutlarda bir hayalet pencereyle değiştirir.	testkucuk	test 3	2022-06-21 00:00:00+03	t	4	2
\.


--
-- Data for Name: Categories; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Categories" ("CategoryID", "CategoryName", "CategoryDescription", "CategoryStatus") FROM stdin;
1	Yazılım	Yazılım Alanındaki herşey	t
2	Donanım	Donanımla ilgili herşey\n	t
3	Backend	Database falan filan	t
4	Frontend	Tasarım falan filan	t
5	Mobile	React-Native falan filan\n	t
\.


--
-- Data for Name: Comments; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Comments" ("CommentID", "CommentUsername", "CommentTitle", "CommentContent", "CommentDate", "CommentStatus", "BlogID") FROM stdin;
1	İsak Yıldırım\n	Vakittttt	Abi Kimse benim vaktimi boşa harcayamaz ulan !	2022-06-06 00:00:00+03	t	1
2	Mehmet Erdem\n	İsaaak	Kes ağlamayı İsak	2022-06-07 00:00:00+03	t	1
3	Mehmet Ali Okudan	Teşekkürler Hocam	Her şey için çok teşekkürler Furkan Hocam\n	2022-06-08 00:00:00+03	t	2
4	Berkay Türk	İdare Eder	Çokta faydalı değil. :(	2022-06-09 00:00:00+03	t	2
5	Berkay KayKay	Bir Saniye 	Yarın ne yiyoz Furkannnn ?_?	2022-06-05 00:00:00+03	t	16
\.


--
-- Data for Name: Contacts; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Contacts" ("ContactID", "ContactUsername", "CantactMail", "ContactSubject", "ContactMessage", "ContactDate", "ContactStatus") FROM stdin;
\.


--
-- Data for Name: Writers; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Writers" ("WriterID", "WriterName", "WriterAbaout", "WriterImage", "WriterMail", "WriterPassword", "WriterStatus") FROM stdin;
1	Osman BAŞ	Kütahya 1995	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/6.jpg	osmanbastr12@gmail.com	123456Ab	t
2	Furkan TAŞÇI	Rize 2001	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/7.jpg	esquetta@gmail.com	53Rize53rte	t
3	Berkay Türko	Sakarya 1999	https://localhost:7037/CoreBlogTema-main/CoreBlogTema-main/CoreBlogTema/web/images/3.jpg	berkayturk5481@gmail.com	123	t
\.


--
-- Data for Name: __EFMigrationsHistory; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."__EFMigrationsHistory" ("MigrationId", "ProductVersion") FROM stdin;
20220517164105_Add-Migration mig1	6.0.5
20220517172529_mig2	6.0.5
20220518123534_mig3	6.0.5
20220603141420_mig4	6.0.5
20220603141533_mig5	6.0.5
20220606143009_mig6	6.0.5
\.


--
-- Name: Abouts_AboutID_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."Abouts_AboutID_seq"', 1, false);


--
-- Name: Blogs_BlogID_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."Blogs_BlogID_seq"', 3, true);


--
-- Name: Categories_CategoryID_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."Categories_CategoryID_seq"', 1, false);


--
-- Name: Comments_CommentID_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."Comments_CommentID_seq"', 1, false);


--
-- Name: Contacts_ContactID_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."Contacts_ContactID_seq"', 1, false);


--
-- Name: Writers_WriterID_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."Writers_WriterID_seq"', 1, false);


--
-- Name: Abouts PK_Abouts; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Abouts"
    ADD CONSTRAINT "PK_Abouts" PRIMARY KEY ("AboutID");


--
-- Name: Blogs PK_Blogs; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Blogs"
    ADD CONSTRAINT "PK_Blogs" PRIMARY KEY ("BlogID");


--
-- Name: Categories PK_Categories; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Categories"
    ADD CONSTRAINT "PK_Categories" PRIMARY KEY ("CategoryID");


--
-- Name: Comments PK_Comments; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Comments"
    ADD CONSTRAINT "PK_Comments" PRIMARY KEY ("CommentID");


--
-- Name: Contacts PK_Contacts; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Contacts"
    ADD CONSTRAINT "PK_Contacts" PRIMARY KEY ("ContactID");


--
-- Name: Writers PK_Writers; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Writers"
    ADD CONSTRAINT "PK_Writers" PRIMARY KEY ("WriterID");


--
-- Name: __EFMigrationsHistory PK___EFMigrationsHistory; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."__EFMigrationsHistory"
    ADD CONSTRAINT "PK___EFMigrationsHistory" PRIMARY KEY ("MigrationId");


--
-- Name: IX_Blogs_CategoryID; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX "IX_Blogs_CategoryID" ON public."Blogs" USING btree ("CategoryID");


--
-- Name: IX_Blogs_WriterID; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX "IX_Blogs_WriterID" ON public."Blogs" USING btree ("WriterID");


--
-- Name: IX_Comments_BlogID; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX "IX_Comments_BlogID" ON public."Comments" USING btree ("BlogID");


--
-- Name: Blogs FK_Blogs_Categories_CategoryID; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Blogs"
    ADD CONSTRAINT "FK_Blogs_Categories_CategoryID" FOREIGN KEY ("CategoryID") REFERENCES public."Categories"("CategoryID") ON DELETE CASCADE;


--
-- Name: Blogs FK_Blogs_Writers_WriterID; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Blogs"
    ADD CONSTRAINT "FK_Blogs_Writers_WriterID" FOREIGN KEY ("WriterID") REFERENCES public."Writers"("WriterID") ON DELETE SET NULL;


--
-- Name: Comments FK_Comments_Blogs_BlogID; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."Comments"
    ADD CONSTRAINT "FK_Comments_Blogs_BlogID" FOREIGN KEY ("BlogID") REFERENCES public."Blogs"("BlogID") ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

